// Compiler Generator NeoCoco/R,
// Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
// extended by M. Loeberbauer & A. Woess, Univ. of Linz
// with improvements by Pat Terry, Rhodes University
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
// As an exception, it is allowed to write an extension of NeoCoco/R that is
// used as a plugin in non-free software.
//
// If not otherwise stated, any source code generated by NeoCoco/R (other than
// NeoCoco/R itself) does not fall under the GNU General Public License.
// -------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
  Trace output options
  0 | A: prints the states of the scanner automaton
  1 | F: prints the First and Follow sets of all nonterminals
  2 | G: prints the syntax graph of the productions
  3 | I: traces the computation of the First sets
  4 | J: prints the sets associated with ANYs and synchronisation sets
  6 | S: prints the symbol table (terminals, nonterminals, pragmas)
  7 | X: prints a cross reference list of all syntax symbols
  8 | P: prints statistics about the NeoCoco run

  Trace output can be switched on by the pragma
    $ { digit | letter }
  in the attributed grammar or as a command-line option
  -------------------------------------------------------------------------*/

using System;
using System.IO;
using System.Linq;

namespace NeoCoco
{
	public class NeoCoco
	{

		public static int Main(string[] args)
		{
			Console.WriteLine("NeoCoco/R (2021)");
			int retVal = 1;

			var nsName = GetOptions(args, "--namespace", "undefined");
			var frameDir = GetOptions(args, "--frames", ".");
			var ddtString = GetOptions(args, "--trace");
			var outDir = GetOptions(args, "--output");
			var emitLines = GetOptions(args, "--lines") is not null;
			var srcName = args[0];

			if (args.Length > 0 && srcName is { })
			{
				string srcDir = Path.GetDirectoryName(srcName) ?? ".";
				var traceFileName = Path.Combine(srcDir, "trace.txt");
				try
				{

					Scanner scanner = new Scanner(srcName);
					Parser parser = new Parser(scanner);

					using var traceWriter = new StreamWriter(new FileStream(traceFileName, FileMode.Create));
					parser.trace = traceWriter;
					parser.tab = new Tab(parser);
					parser.dfa = new DFA(parser);
					parser.pgen = new ParserGenerator(parser);

					parser.tab.srcName = srcName;
					parser.tab.srcDir = srcDir;
					parser.tab.nsName = nsName;
					parser.tab.frameDir = frameDir;
					parser.tab.outDir = outDir ?? srcDir;
					parser.tab.emitLines = emitLines;
					if (ddtString != null) parser.tab.SetDDT(ddtString);

					parser.Parse();

					parser.trace.Close();
					var f = new FileInfo(traceFileName);
					if (f.Length == 0) f.Delete();
					else Console.WriteLine("trace output is in " + traceFileName);
					Console.WriteLine(" errors detected", parser.errors.count);
					if (parser.errors.count == 0) { retVal = 0; }
				}
				catch (IOException)
				{
					Console.WriteLine("-- could not open " + traceFileName);
				}
				catch (FatalError e)
				{
					Console.WriteLine("-- " + e.Message);
				}
			}
			else
			{
				Console.WriteLine("Usage: NeoCoco Grammar.ATG {{Option}}");
				Console.WriteLine( "Options:");
				Console.WriteLine( "  --namespace <namespaceName>");
				Console.WriteLine( "  --frames    <frameFilesDirectory>");
				Console.WriteLine( "  --trace     <traceString>");
				Console.WriteLine( "  --o         <outputDirectory>");
				Console.WriteLine( "  --lines");
				Console.WriteLine( "Valid characters in the trace string:");
				Console.WriteLine( "  A  trace automaton");
				Console.WriteLine( "  F  list first/follow sets");
				Console.WriteLine( "  G  print syntax graph");
				Console.WriteLine( "  I  trace computation of first sets");
				Console.WriteLine( "  J  list ANY and SYNC sets");
				Console.WriteLine( "  P  print statistics");
				Console.WriteLine( "  S  list symbol table");
				Console.WriteLine( "  X  list cross reference table");
				Console.WriteLine( "Scanner.frame and Parser.frame files needed in ATG directory");
				Console.WriteLine( "or in a directory specified in the -frames option.");
			}
			return retVal;
		}

		private static string GetOptions(string[] args, string argName)
		{
			var opt = args.SkipWhile(x => x != argName);
			var present = opt.Any();
			if (!present)
			{
				return null;
			}
			else
			{
				var values = opt.Skip(1).TakeWhile(x => !x.StartsWith("--"));
				return values.FirstOrDefault();
			}
		}
		private static string GetOptions(string[] args, string argName, string defaultValue) =>
				(GetOptions(args, argName) is { } value) ? value : defaultValue;

		private static int GetOptions(string[] args, string argName, int defaultValue) =>
				(GetOptions(args, argName) is { } value) ? int.Parse(value) : defaultValue;
	}
}
