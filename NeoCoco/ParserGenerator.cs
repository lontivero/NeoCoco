// ParserGenerator.cs -- Generation of the Recursive Descent Parser
// Compiler Generator NeoCoco/R,
// Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
// extended by M. Loeberbauer & A. Woess, Univ. of Linz
// with improvements by Pat Terry, Rhodes University
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
// As an exception, it is allowed to write an extension of NeoCoco/R that is
// used as a plugin in non-free software.
//
// If not otherwise stated, any source code generated by NeoCoco/R (other than
// NeoCoco/R itself) does not fall under the GNU General Public License.
// -------------------------------------------------------------------------
using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;

namespace NeoCoco
{
	public class ParserGenerator
	{

		const int maxTerm = 3;      // sets of size < maxTerm are enumerated
		const char CR = '\r';
		const char LF = '\n';
		const int EOF = -1;

		const int tErr = 0;         // error codes
		const int altErr = 1;
		const int syncErr = 2;

		public Position usingPos; // "using" definitions from the attributed grammar

		int errorNr;      // highest parser error number
		Symbol curSy;     // symbol whose production is currently generated
		FileStream fram;  // parser frame file
		StreamWriter gen; // generated parser source file
		StringWriter err; // generated parser error messages
		List<BitArray> symSet = new ();

		Tab tab;          // other NeoCoco objects
		TextWriter trace;
		Buffer buffer;

		void Indent(int n)
		{
			for (int i = 1; i <= n; i++) gen.Write('\t');
		}

		bool Overlaps(BitArray s1, BitArray s2)
		{
			int len = s1.Count;
			for (int i = 0; i < len; ++i)
			{
				if (s1[i] && s2[i])
				{
					return true;
				}
			}
			return false;
		}

		// use a switch if more than 5 alternatives and none starts with a resolver, and no LL1 warning
		bool UseSwitch(Node p)
		{
			BitArray s1, s2;
			if (p.Type != NodeType.Alternative) return false;
			int nAlts = 0;
			s1 = new BitArray(tab.terminals.Count);
			while (p != null)
			{
				s2 = tab.Expected0(p.sub, curSy);
				// must not optimize with switch statement, if there are ll1 warnings
				if (Overlaps(s1, s2)) { return false; }
				s1.Or(s2);
				++nAlts;
				// must not optimize with switch-statement, if alt uses a resolver expression
				if (p.sub.Type == NodeType.ResolverExpr) return false;
				p = p.down;
			}
			return nAlts > 5;
		}

		void CopySourcePart(Position pos, int indent)
		{
			// Copy text described by pos from atg to gen
			int ch, i;
			if (pos != null)
			{
				buffer.Pos = pos.Begin; ch = buffer.Read();
				if (tab.emitLines)
				{
					gen.WriteLine();
					gen.WriteLine("#line {0} \"{1}\"", pos.Line, tab.srcName);
				}
				Indent(indent);
				while (buffer.Pos <= pos.End)
				{
					while (ch is CR or LF)
					{  // eol is either CR or CRLF or LF
						gen.WriteLine(); Indent(indent);
						if (ch == CR) ch = buffer.Read(); // skip CR
						if (ch == LF) ch = buffer.Read(); // skip LF
						for (i = 1; i <= pos.Column && (ch == ' ' || ch == '\t'); i++)
						{
							// skip blanks at beginning of line
							ch = buffer.Read();
						}
						if (buffer.Pos > pos.End) goto done;
					}
					gen.Write((char)ch);
					ch = buffer.Read();
				}
			done:
				if (indent > 0) gen.WriteLine();
			}
		}

		void GenErrorMsg(int errTyp, Symbol sym)
		{
			errorNr++;
			err.Write("\t\t\tcase " + errorNr + ": s = \"");
			switch (errTyp)
			{
				case tErr:
					if (sym.Name[0] == '"') err.Write(tab.Escape(sym.Name) + " expected");
					else err.Write(sym.Name + " expected");
					break;
				case altErr: err.Write("invalid " + sym.Name); break;
				case syncErr: err.Write("this symbol not expected in " + sym.Name); break;
			}
			err.WriteLine("\"; break;");
		}

		int NewCondSet(BitArray s)
		{
			for (int i = 1; i < symSet.Count; i++) // skip symSet[0] (reserved for union of SYNC sets)
			{
				if (s.Equals(symSet[i]))
				{
					 return i;
				}
			}
			symSet.Add((BitArray)s.Clone());
			return symSet.Count - 1;
		}

		void GenCond(BitArray s, Node p)
		{
			if (p.Type == NodeType.ResolverExpr)
			{
				 CopySourcePart(p.pos, 0);
			}
			else
			{
				int n = s.Elements();
				if (n == 0)
				{
					 gen.Write("false"); // happens if an ANY set matches no symbol
				}
				else if (n <= maxTerm)
				{
					foreach (Symbol sym in tab.terminals)
					{
						if (s[sym.n])
						{
							gen.Write($"lookaheadToken.kind == {sym.n} /* {sym.GetName()} */");
							--n;
							if (n > 0) gen.Write(" || ");
						}
					}
				}
				else
				{
					gen.Write($"StartOf({NewCondSet(s)})");
				}
			}
		}

		void PutCaseLabels(BitArray s, int indent)
		{
			foreach (Symbol sym in tab.terminals)
			{
				if (s[sym.n])
				{
					gen.WriteLine($"case {sym.n}: /*  {sym.GetName()} */" );
					Indent(indent);
				}
			}
		}

		void GenCode(Node p, int indent, BitArray isChecked)
		{
			Node p2;
			BitArray s1, s2;
			while (p != null)
			{
				switch (p.Type)
				{
					case NodeType.NonTerminal:
						{
							Indent(indent);
							gen.Write(p.Symbol.Name + "(");
							CopySourcePart(p.pos, 0);
							gen.WriteLine(");");
							break;
						}
					case NodeType.Terminal:
						{
							Indent(indent);
							// assert: if isChecked[p.sym.n] is true, then isChecked contains only p.sym.n
							if (isChecked[p.Symbol.n]) gen.WriteLine("Get();");
							else gen.WriteLine($"Expect({p.Symbol.n} /* {p.Symbol.GetName()} */);");
							break;
						}
					case NodeType.WeakTerminal:
						{
							Indent(indent);
							s1 = tab.Expected(p.next, curSy);
							s1.Or(tab.allSyncSets);
							gen.WriteLine($"ExpectWeak({p.Symbol.n} /* {p.Symbol.GetName()} */, {NewCondSet(s1)});");
							break;
						}
					case NodeType.Any:
						{
							Indent(indent);
							int acc = p.set.Elements();
							if (tab.terminals.Count == (acc + 1) || (acc > 0 && p.set.IsEqual(isChecked)))
							{
								// either this ANY accepts any terminal (the + 1 = end of file), or exactly what's allowed here
								gen.WriteLine("Get();");
							}
							else
							{
								GenErrorMsg(altErr, curSy);
								if (acc > 0)
								{
									gen.Write("if ("); GenCond(p.set, p); gen.WriteLine(") Get(); else SynErr({0});", errorNr);
								}
								else gen.WriteLine("SynErr({0}); // ANY node that matches no symbol", errorNr);
							}
							break;
						}
					case NodeType.Empty: break; // nothing
					case NodeType.ResolverExpr: break; // nothing
					case NodeType.SemanticAction:
						{
							CopySourcePart(p.pos, indent);
							break;
						}
					case NodeType.Synchronization:
						{
							Indent(indent);
							GenErrorMsg(syncErr, curSy);
							s1 = (BitArray)p.set.Clone();
							gen.Write("while (!("); GenCond(s1, p); gen.Write(")) {");
							gen.Write("SynErr({0}); Get();", errorNr); gen.WriteLine("}");
							break;
						}
					case NodeType.Alternative:
						{
							s1 = tab.First(p);
							bool equal = s1.IsEqual(isChecked);
							bool useSwitch = UseSwitch(p);
							if (useSwitch) { Indent(indent); gen.WriteLine("switch (lookaheadToken.kind) {"); }
							p2 = p;
							while (p2 != null)
							{
								s1 = tab.Expected(p2.sub, curSy);
								Indent(indent);
								if (useSwitch)
								{
									PutCaseLabels(s1, indent); gen.WriteLine("{");
								}
								else if (p2 == p)
								{
									gen.Write("if ("); GenCond(s1, p2.sub); gen.WriteLine(") {");
								}
								else if (p2.down == null && equal)
								{
									gen.WriteLine("} else {");
								}
								else
								{
									gen.Write("} else if ("); GenCond(s1, p2.sub); gen.WriteLine(") {");
								}
								GenCode(p2.sub, indent + 1, s1);
								if (useSwitch)
								{
									Indent(indent); gen.WriteLine("\tbreak;");
									Indent(indent); gen.WriteLine("}");
								}
								p2 = p2.down;
							}
							Indent(indent);
							if (equal)
							{
								gen.WriteLine("}");
							}
							else
							{
								GenErrorMsg(altErr, curSy);
								if (useSwitch)
								{
									gen.WriteLine("default: SynErr({0}); break;", errorNr);
									Indent(indent); gen.WriteLine("}");
								}
								else
								{
									gen.Write("} "); gen.WriteLine("else SynErr({0});", errorNr);
								}
							}
							break;
						}
					case NodeType.Iteration:
						{
							Indent(indent);
							p2 = p.sub;
							gen.Write("while (");
							if (p2.Type == NodeType.WeakTerminal)
							{
								s1 = tab.Expected(p2.next, curSy);
								s2 = tab.Expected(p.next, curSy);
								gen.Write("WeakSeparator({0},{1},{2}) ", p2.Symbol.n, NewCondSet(s1), NewCondSet(s2));
								s1 = new BitArray(tab.terminals.Count);  // for inner structure
								if (p2.up || p2.next == null) p2 = null; else p2 = p2.next;
							}
							else
							{
								s1 = tab.First(p2);
								GenCond(s1, p2);
							}
							gen.WriteLine(") {");
							GenCode(p2, indent + 1, s1);
							Indent(indent); gen.WriteLine("}");
							break;
						}
					case NodeType.Option:
						s1 = tab.First(p.sub);
						Indent(indent);
						gen.Write("if ("); GenCond(s1, p.sub); gen.WriteLine(") {");
						GenCode(p.sub, indent + 1, s1);
						Indent(indent); gen.WriteLine("}");
						break;
				}
				if (p.Type != NodeType.Empty && p.Type != NodeType.SemanticAction && p.Type != NodeType.Synchronization)
					isChecked.SetAll(false);  // = new BitArray(tab.terminals.Count);
				if (p.up) break;
				p = p.next;
			}
		}

		void GenTokens()
		{
			foreach (Symbol sym in tab.terminals)
			{
				if (Char.IsLetter(sym.Name[0]))
				{
					gen.WriteLine("\tpublic const int _{0} = {1};", sym.Name, sym.n);
				}
			}
		}

		void GenPragmas()
		{
			foreach (Symbol sym in tab.pragmas)
			{
				gen.WriteLine("\tpublic const int _{0} = {1};", sym.Name, sym.n);
			}
		}

		void GenCodePragmas()
		{
			foreach (Symbol sym in tab.pragmas)
			{
				gen.WriteLine($"\t\tif (lookaheadToken.kind == {sym.n}) {{");
				CopySourcePart(sym.semPos, 4);
				gen.WriteLine("\t\t}");
			}
		}

		void GenProductions()
		{
			foreach (Symbol sym in tab.nonterminals)
			{
				curSy = sym;
				gen.Write("\tvoid {0}(", sym.Name);
				CopySourcePart(sym.attrPos, 0);
				gen.WriteLine(") {");
				CopySourcePart(sym.semPos, 2);
				GenCode(sym.graph, 2, new BitArray(tab.terminals.Count));
				gen.WriteLine("\t}"); gen.WriteLine();
			}
		}

		void InitSets()
		{
			for (int i = 0; i < symSet.Count; i++)
			{
				var s = symSet[i];
				gen.Write("\t\t{");
				int j = 0;
				foreach (Symbol sym in tab.terminals)
				{
					gen.Write(s[sym.n] ? "true, " : "false, ");
					++j;
					if (j % 4 == 0)
					{
						gen.Write(" ");
					}
				}
				gen.Write("false}");
				if (i != symSet.Count - 1)
				{
					gen.WriteLine(",");
				}
			}
		}

		public void WriteParser()
		{
			Generator g = new Generator(tab);
			int oldPos = buffer.Pos;  // Pos is modified by CopySourcePart
			symSet.Add(tab.allSyncSets);

			fram = g.OpenFrame("Parser.frame");
			gen = g.OpenGen("Parser.generated.cs");
			err = new StringWriter();
			foreach (Symbol sym in tab.terminals) GenErrorMsg(tErr, sym);

			g.SkipFramePart("-->begin");

			if (usingPos != null) { CopySourcePart(usingPos, 0); gen.WriteLine(); }
			g.CopyFramePart("-->namespace");
			/* AW open namespace, if it exists */
			if (tab.nsName != null && tab.nsName.Length > 0)
			{
				gen.WriteLine("namespace {0} {{", tab.nsName);
				gen.WriteLine();
			}
			g.CopyFramePart("-->constants");
			gen.WriteLine("\tpublic const int MaxTerminal = {0};", tab.terminals.Count - 1);
			GenPragmas(); /* ML 2005/09/23 write the pragma kinds */
			g.CopyFramePart("-->declarations"); CopySourcePart(tab.semDeclPos, 0);
			g.CopyFramePart("-->pragmas"); GenCodePragmas();
			g.CopyFramePart("-->productions"); GenProductions();
			g.CopyFramePart("-->parseRoot"); gen.WriteLine("\t\t{0}();", tab.gramSy.Name);
			if (tab.checkEOF) gen.WriteLine("\t\tExpect(0);");
			g.CopyFramePart("-->initialization"); InitSets();
			g.CopyFramePart("-->errors"); gen.Write(err.ToString());
			g.CopyFramePart(null);
			/* AW 2002-12-20 close namespace, if it exists */
			if (tab.nsName != null && tab.nsName.Length > 0) gen.Write("}");
			gen.Close();
			buffer.Pos = oldPos;
		}

		public void WriteStatistics()
		{
			trace.WriteLine();
			trace.WriteLine("{0} terminals", tab.terminals.Count);
			trace.WriteLine("{0} symbols", tab.terminals.Count + tab.pragmas.Count + tab.nonterminals.Count);
			trace.WriteLine("{0} nodes", tab.nodes.Count);
			trace.WriteLine("{0} sets", symSet.Count);
		}

		public ParserGenerator(Parser parser)
		{
			tab = parser.tab;
			trace = parser.trace;
			buffer = parser.scanner.buffer;
			errorNr = -1;
			usingPos = null;
		}
	}
}
