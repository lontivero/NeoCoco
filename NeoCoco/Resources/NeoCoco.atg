// NeoCoco.ATG -- Attributed Grammar
// Compiler Generator NeoCoco/R,
// Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
// extended by M. Loeberbauer & A. Woess, Univ. of Linz
// with improvements by Pat Terry, Rhodes University
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
// As an exception, it is allowed to write an extension of NeoCoco/R that is
// used as a plugin in non-free software.
//
// If not otherwise stated, any source code generated by NeoCoco/R (other than
// NeoCoco/R itself) does not fall under the GNU General Public License.
// -------------------------------------------------------------------------

$namespace=NeoCoco

using System.IO;

COMPILER NeoCoco

	const int IdentifierKind = 0;
	const int StringKind = 1;

	public TextWriter trace;    // other NeoCoco objects referenced in this ATG
	public Tab tab;
	public DFA dfa;
	public ParserGenerator pgen;

	bool   genScanner;
	string tokenString;         // used in declarations of literal tokens
	string noString = "-none-"; // used in declarations of literal tokens

/*-------------------------------------------------------------------------*/

CHARACTERS
	letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
	digit     = "0123456789".
	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.
	stringCh  = ANY - '"' - '\\' - cr - lf.
	charCh    = ANY - '\'' - '\\' - cr - lf.
	printable = '\u0020' .. '\u007e'.
	hex       = "0123456789abcdef".

TOKENS
	ident     = letter { letter | digit }.
	number    = digit { digit }.
	string    = '"' { stringCh | '\\' printable } '"'.
	badString = '"' { stringCh | '\\' printable } (cr | lf).
	char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
	ddtSym    = '$' { digit | letter }.  (. tab.SetDDT(lookaheadToken.val); .)

	optionSym = '$' letter { letter } '='
	            { digit | letter
	            | '-' | '.' | ':'
	            }.                       (. tab.SetOption(lookaheadToken.val); .)


COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

NeoCoco                          (. Symbol sym; Graph g, g1, g2; string gramName; CharSet s; int beg, line; .)
=
  [ // using statements
    ANY                          (. beg = lastToken.pos; line = lastToken.line; .)
    { ANY }                      (. pgen.usingPos = new Position(beg, lookaheadToken.pos, 0, line); .)
  ]

  "COMPILER"                    (. genScanner = true; .)
  ident                         (. gramName = lastToken.val;
                                   beg = lookaheadToken.pos; line = lookaheadToken.line;
                                .)
  { ANY }                       (. tab.semDeclPos = new Position(beg, lookaheadToken.pos, 0, line); .)
  [ "IGNORECASE"                (. dfa.ignoreCase = true; .) ]   /* pdt */
  [ "CHARACTERS" { SetDecl }]
  [ "TOKENS"  { TokenDecl<NodeType.Terminal> }]
  [ "PRAGMAS" { TokenDecl<NodeType.Pragma> }]
  { "COMMENTS"                  (. bool nested = false; .)
    "FROM" TokenExpr<out g1>
    "TO" TokenExpr<out g2>
    [ "NESTED"                  (. nested = true; .)
    ]                           (. dfa.NewComment(g1.Left, g2.Left, nested); .)
  }
  { "IGNORE" Set<out s>         (. tab.Ignored.Or(s); .)
  }

  SYNC
  "PRODUCTIONS"                 (. if (genScanner) dfa.MakeDeterministic();
                                   tab.DeleteNodes();
                                 .)
  { ident                       (. var undef = !tab.TryFindSymbol(lastToken.val, out sym);
                                   if (undef)
                                   {
                                      sym = tab.NewSym(NodeType.NonTerminal, lastToken.val, lastToken.line);
                                   }
                                   else
                                   {
                                      if (sym.Type == NodeType.NonTerminal)
                                      {
                                        if (sym.graph != null) SemErr("name declared twice");
                                   	  }
                                      else
                                      {
                                        SemErr("this symbol kind not allowed on left side of production");
                                      }
                                   	  sym.line = lastToken.line;
                                   }
                                   bool noAttrs = sym.attrPos == null;
                                   sym.attrPos = null;
                                 .)
    [ AttrDecl<sym> ]           (. if (!undef)
                                     if (noAttrs != (sym.attrPos == null))
                                       SemErr("attribute mismatch between declaration and use of this symbol");
                                 .)
    [ SemText<out sym.semPos> ] WEAK
    '='
    Expression<out g>           (. sym.graph = g.Left;
                                   tab.Finish(g);
                                 .)
                                WEAK
    '.'
  }
  "END" ident                   (. if (gramName != lastToken.val)
                                     SemErr("name does not match grammar name");

                                   if (!tab.TryFindSymbol(gramName, out tab.gramSy))
                                     SemErr("missing production for grammar name");
                                   else {
                                     sym = tab.gramSy;
                                     if (sym.attrPos != null)
                                       SemErr("grammar symbol must not have attributes");
                                   }
                                   tab.noSym = tab.NewSym(NodeType.Terminal, "???", 0); // noSym gets highest number
                                   tab.SetupAnys();
                                   tab.RenumberPragmas();
                                   if (tab.ddt[2]) tab.PrintNodes();
                                   if (errors.count == 0) {
                                     tab.CompSymbolSets();
                                     if (tab.ddt[7]) tab.XRef();
                                     if (tab.GrammarOk()) {
                                       pgen.WriteParser();
                                       if (genScanner) {
                                         dfa.WriteScanner();
                                         if (tab.ddt[0]) dfa.PrintStates();
                                       }
                                       if (tab.ddt[8]) pgen.WriteStatistics();
                                     }
                                   }
                                   if (tab.ddt[6]) tab.PrintSymbolTable();
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SetDecl                         (. CharSet s; .)
=
  ident                         (. string name = lastToken.val;
                                   CharClass c = tab.FindCharClass(name);
                                   if (c != null) SemErr("name declared twice");
                                 .)
  '=' Set<out s>                (. if (s.Elements() == 0) SemErr("character set must not be empty");
                                   tab.NewCharClass(name, s);
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

Set<out CharSet s>              (. CharSet s2; .)
=
  SimSet<out s>
  { '+' SimSet<out s2>          (. s.Or(s2); .)
  | '-' SimSet<out s2>          (. s.Subtract(s2); .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<out CharSet s>           (. int n1, n2; .)
=                               (. s = new CharSet(); .)
( ident                         (. var c = tab.FindCharClass(lastToken.val);
                                   if (c == null) SemErr("undefined name"); else s.Or(c.Set);
                                 .)
| string                        (. var name = lastToken.val;
                                   name = tab.Unescape(name.Substring(1, name.Length-2));
                                   foreach (char ch in name)
                                   {
                                     s.Set(dfa.ignoreCase ? char.ToLower(ch) : ch);
                                   }
                                .)
| Char<out n1>                  (. s.Set(n1); .)
  [ ".." Char<out n2>           (. for (int i = n1; i <= n2; i++) s.Set(i); .)
  ]
| "ANY"                         (. s = new CharSet(); s.Fill(); .)
)
.

/*--------------------------------------------------------------------------------------*/

Char<out int n>
=
  char                          (. string name = lastToken.val; n = 0;
                                   name = tab.Unescape(name.Substring(1, name.Length-2));
                                   if (name.Length == 1) n = name[0];
                                   else SemErr("unacceptable character value");
                                   if (dfa.ignoreCase && (char)n >= 'A' && (char)n <= 'Z') n += 32;
                                 .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<NodeType type>        (. string name; int kind; Symbol sym; Graph g; .)
=
  Sym<out name, out kind>       (.
                                   if (tab.TryFindSymbol(name, out sym))
                                   {
                                     SemErr("name declared twice");
                                   }
                                   else
                                   {
                                     sym = tab.NewSym(type, name, lastToken.line);
                                     sym.tokenKind = Symbol.fixedToken;
                                   }
                                   tokenString = null;
                                 .)
  SYNC
  ( '=' TokenExpr<out g> '.'    (. if (kind == StringKind) SemErr("a literal must not be declared with a structure");
                                   tab.Finish(g);
                                   if (tokenString == null || tokenString.Equals(noString))
                                     dfa.ConvertToStates(g.Left, sym);
                                   else // TokenExpr is a single string
                                   {
                                     if (tab.literals.ContainsKey(tokenString))
                                       SemErr("token string declared twice");
                                     tab.literals[tokenString] = sym;
                                     dfa.MatchLiteral(tokenString, sym);
                                   }
                                 .)
  |                             (. if (kind == IdentifierKind) genScanner = false;
                                   else dfa.MatchLiteral(sym.Name, sym);
                                 .)
  )
  [ SemText<out sym.semPos>     (. if (type != NodeType.Pragma) SemErr("semantic action not allowed here"); .)
  ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl<Symbol sym>
=
  '<'                           (. var beg = lookaheadToken.pos; var col = lookaheadToken.col; var line = lookaheadToken.line; .)
  { ANY
  | badString                   (. SemErr("bad string in attributes"); .)
  }
  '>'                           (. if (lastToken.pos > beg)
                                     sym.attrPos = new Position(beg, lastToken.pos, col, line); .)
| "<."                          (. var beg = lookaheadToken.pos; var col = lookaheadToken.col; var line = lookaheadToken.line; .)
  { ANY
  | badString                   (. SemErr("bad string in attributes"); .)
  }
  ".>"                          (. if (lastToken.pos > beg)
                                     sym.attrPos = new Position(beg, lastToken.pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

Expression<out Graph g>         (. Graph g2; .)
=
  Term<out g>                   (. bool first = true; .)
  {                             WEAK
    '|'
    Term<out g2>                (. if (first) { tab.MakeFirstAlt(g); first = false; }
                                   tab.MakeAlternative(g, g2);
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<out Graph g>               (. Graph g2; Node rslv = null; g = null; .)
=
( [                             (. rslv = tab.NewNode(NodeType.ResolverExpr, null, lookaheadToken.line); .)
    Resolver<out rslv.pos>      (. g = new Graph(rslv); .)
  ]
  Factor<out g2>                (. if (rslv != null) tab.MakeSequence(g, g2);
                                   else g = g2;
                                 .)
  { Factor<out g2>              (. tab.MakeSequence(g, g2); .)
  }
|                               (. g = new Graph(tab.NewNode(NodeType.Empty, null, 0)); .)
)                               (. if (g == null) // invalid start of Term
                                     g = new Graph(tab.NewNode(NodeType.Empty, null, 0));
                                 .)
.

/*------------------------------------------------------------------------------------*/

Factor<out Graph g>             (. string name; int kind; Position pos; bool weak = false;
                                   g = null;
                                 .)
=
( [ "WEAK"                      (. weak = true; .)
  ]
  Sym<out name, out kind>       (. var undef = !tab.TryFindSymbol(name, out var sym);
                                   if (undef)
                                   {
                                      if (kind == StringKind)
                                      {
                                        tab.literals.TryGetValue(name, out sym);
                                      }
                                      if (kind == IdentifierKind)
                                      {
                                        sym = tab.NewSym(NodeType.NonTerminal, name, 0);  // forward nt
                                      }
                                      else if (genScanner)
                                      {
                                        sym = tab.NewSym(NodeType.Terminal, name, lastToken.line);
                                        dfa.MatchLiteral(sym.Name, sym);
                                      }
                                      else
                                      {  // undefined string in production
                                        SemErr("undefined string in production");
                                        sym = tab.eofSy;  // dummy
                                      }
                                   }
                                   var type = sym.Type;
                                   if (type != NodeType.Terminal && type != NodeType.NonTerminal)
                                     SemErr("this symbol kind is not allowed in a production");
                                   if (weak)
                                     if (type == NodeType.Terminal) type = NodeType.WeakTerminal;
                                     else SemErr("only terminals may be weak");
                                   Node p = tab.NewNode(type, sym, lastToken.line);
                                   g = new Graph(p);
                                 .)
  [ Attribs<p>                  (. if (kind != IdentifierKind) SemErr("a literal must not have attributes"); .)
  ]                             (. if (undef)
                                     sym.attrPos = p.pos;  // dummy
                                   else if ((p.pos == null) != (sym.attrPos == null))
                                     SemErr("attribute mismatch between declaration and use of this symbol");
                                 .)
| '(' Expression<out g> ')'
| '[' Expression<out g> ']'     (. tab.MakeOption(g); .)
| '{' Expression<out g> '}'     (. tab.MakeIteration(g); .)
| SemText<out pos>              (. Node p = tab.NewNode(NodeType.SemanticAction, null, 0);
                                   p.pos = pos;
                                   g = new Graph(p);
                                 .)
| "ANY"                         (. Node p = tab.NewNode(NodeType.Any, null, 0);  // p.set is set in tab.SetupAnys
                                   g = new Graph(p);
                                 .)
| "SYNC"                        (. Node p = tab.NewNode(NodeType.Synchronization, null, 0);
                                   g = new Graph(p);
                                 .)
)                               (. if (g == null) // invalid start of Factor
                                     g = new Graph(tab.NewNode(NodeType.Empty, null, 0));
                                 .)
.

/*------------------------------------------------------------------------------------*/

Resolver<out Position pos>
=
  "IF" "("                       (. int beg = lookaheadToken.pos; int col = lookaheadToken.col; int line = lookaheadToken.line; .)
  Condition                      (. pos = new Position(beg, lastToken.pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<out Graph g>          (. Graph g2; .)
=
  TokenTerm<out g>              (. bool first = true; .)
  {                             WEAK
    '|'
    TokenTerm<out g2>           (. if (first) { tab.MakeFirstAlt(g); first = false; }
                                   tab.MakeAlternative(g, g2);
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

TokenTerm<out Graph g>          (. Graph g2; .)
=
  TokenFactor<out g>
  { TokenFactor<out g2>         (. tab.MakeSequence(g, g2); .)
  }
  [ "CONTEXT"
    '(' TokenExpr<out g2>       (. tab.SetContextTrans(g2.Left); dfa.hasCtxMoves = true;
                                   tab.MakeSequence(g, g2); .)
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<out Graph g>        (. string name; int kind; .)
=
                                (. g = null; .)
( Sym<out name, out kind>       (. if (kind == IdentifierKind) {
                                     var c = tab.FindCharClass(name);
                                     if (c == null) {
                                       SemErr("undefined name");
                                       c = tab.NewCharClass(name, new CharSet());
                                     }
                                     var p = tab.NewNode(NodeType.Class, null, 0); p.val = c.N;
                                     g = new Graph(p);
                                     tokenString = noString;
                                   } else { // StringKind
                                     g = tab.StrToGraph(name);
                                     if (tokenString == null) tokenString = name;
                                     else tokenString = noString;
                                   }
                                 .)
| '(' TokenExpr<out g> ')'
| '[' TokenExpr<out g> ']'      (. tab.MakeOption(g); tokenString = noString; .)
| '{' TokenExpr<out g> '}'      (. tab.MakeIteration(g); tokenString = noString; .)
)                               (. if (g == null) // invalid start of TokenFactor
                                     g = new Graph(tab.NewNode(NodeType.Empty, null, 0)); .)
.

/*------------------------------------------------------------------------------------*/

Sym<out string name, out int kind>
=                               (. name = "???"; kind = IdentifierKind; .)
( ident                         (. kind = IdentifierKind; name = lastToken.val; .)
| (string                       (. name = lastToken.val; .)
  | char                        (. name = "\"" + lastToken.val.Substring(1, lastToken.val.Length-2) + "\""; .)
  )                             (. kind = StringKind;
                                   if (dfa.ignoreCase) name = name.ToLower();
                                   if (name.IndexOf(' ') >= 0)
                                     SemErr("literal tokens must not contain blanks"); .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs<Node p>
=
  '<'                           (. var beg = lookaheadToken.pos; var col = lookaheadToken.col; var line = lookaheadToken.line; .)
  { ANY
  | badString                   (. SemErr("bad string in attributes"); .)
  }
  '>'                           (. if (lastToken.pos > beg) p.pos = new Position(beg, lastToken.pos, col, line); .)
| "<."                          (. var beg = lookaheadToken.pos; var col = lookaheadToken.col; var line = lookaheadToken.line; .)
  { ANY
  | badString                   (. SemErr("bad string in attributes"); .)
  }
  ".>"                          (. if (lastToken.pos > beg) p.pos = new Position(beg, lastToken.pos, col, line); .)
.

/*------------------------------------------------------------------------------------*/

SemText<out Position pos>
=
  "(."                          (. var beg = lookaheadToken.pos; var col = lookaheadToken.col; var line = lookaheadToken.line; .)
  { ANY
  | badString                   (. SemErr("bad string in semantic action"); .)
  | "(."                        (. SemErr("missing end of previous semantic action"); .)
  }
  ".)"                          (. pos = new Position(beg, lastToken.pos, col, line); .)
.

END NeoCoco.
