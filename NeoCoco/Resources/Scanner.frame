// Compiler Generator NeoCoco/R,
// Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
// extended by M. Loeberbauer & A. Woess, Univ. of Linz
// with improvements by Pat Terry, Rhodes University
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
// As an exception, it is allowed to write an extension of NeoCoco/R that is
// used as a plugin in non-free software.
//
// If not otherwise stated, any source code generated by NeoCoco/R (other than
// NeoCoco/R itself) does not fall under the GNU General Public License.
// -----------------------------------------------------------------------

-->begin
using System;
using System.IO;
using System.Collections.Generic;

-->namespace


//-----------------------------------------------------------------------------------
// Scanner
//-----------------------------------------------------------------------------------
public partial class Scanner
{
-->declarations

	static Scanner()
	{
		start = new Dictionary<int, int>(128);
		-->initialization
	}

	void Casing1()
	{
		-->casing1
	}

	void Casing2()
	{
		-->casing2
	}


-->comments

	void CheckLiteral()
	{
-->literals
	}

	Token NextToken()
	{
		while (ch == ' ' ||
-->scan1
		) NextCh();
-->scan2
		int recKind = noSym;
		int recEnd = pos;
		lastToken = new Token();
		lastToken.pos = pos; lastToken.col = col; lastToken.line = line; lastToken.charPos = charPos;
		int state;
		state = start.ContainsKey(ch) ? start[ch] : 0;
		tlen = 0; AddCh();

		switch (state)
		{
			case -1: { lastToken.kind = eofSym; break; } // NextCh already done
			case 0:
				{
					if (recKind != noSym)
					{
						tlen = recEnd - lastToken.pos;
						SetScannerBehindT();
					}
					lastToken.kind = recKind; break;
				} // NextCh already done
				-->scan3
		}
		lastToken.val = new String(tval, 0, tlen);
		return lastToken;
	}
}

