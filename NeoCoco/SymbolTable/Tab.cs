// Tab.cs -- Symbol Table Management
// Compiler Generator NeoCoco/R,
// Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
// extended by M. Loeberbauer & A. Woess, Univ. of Linz
// with improvements by Pat Terry, Rhodes University
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
// As an exception, it is allowed to write an extension of NeoCoco/R that is
// used as a plugin in non-free software.
//
// If not otherwise stated, any source code generated by NeoCoco/R (other than
// NeoCoco/R itself) does not fall under the GNU General Public License.
// -------------------------------------------------------------------------
using System;
using System.IO;
using System.Text;
using System.Linq;
using System.Collections;
using System.Collections.Generic;

namespace NeoCoco
{
	public class Tab
	{
		public Position semDeclPos;       // position of global semantic declarations
		public CharSet Ignored { get; } = new();           // characters ignored by the scanner
		public bool[] ddt = new bool[10]; // debug and test switches
		public Symbol gramSy;             // root nonterminal; filled by ATG  <--------------------------- make it list<symbol>
		public Symbol eofSy;              // end of file symbol
		public Symbol noSym;              // used in case of an error
		public BitArray allSyncSets;      // union of all synchronisation sets
		public Dictionary<string, Symbol> literals = new();        // symbols that are used as literals

		public string srcName;            // name of the atg file (including path)
		public string srcDir;             // directory path of the atg file
		public string nsName;             // namespace for generated files
		public string frameDir;           // directory containing the frame files
		public string outDir;             // directory for generated files
		public bool checkEOF = true;      // should coco generate a check for EOF at
										  //   the end of Parser.Parse():
		public bool emitLines;            // emit #line pragmas for semantic actions
										  //   in the generated parser

		BitArray visited;                 // mark list for graph traversals
		Symbol curSy;                     // current symbol in computation of sets

		Parser parser;                    // other NeoCoco objects
		TextWriter trace;
		Errors errors;

		public Tab(Parser parser)
		{
			this.parser = parser;
			trace = parser.trace;
			errors = parser.errors;
			eofSy = NewSym(NodeType.Terminal, "EOF", 0);
			dummyNode = NewNode(NodeType.Empty, null, 0);
		}

		//---------------------------------------------------------------------
		//  Symbol list management
		//---------------------------------------------------------------------

		public List<Symbol> terminals = new();
		public List<Symbol> pragmas = new();
		public List<Symbol> nonterminals = new();

		string[] tKind = { "fixedToken", "classToken", "litToken", "classLitToken" };

		public Symbol NewSym(NodeType typ, string name, int line)
		{
			if (name.Length == 2 && name[0] == '"')
			{
				parser.SemErr("empty token not allowed"); name = "???";
			}
			var sym = new Symbol(typ, name, line);
			switch (typ)
			{
				case NodeType.Terminal: sym.n = terminals.Count; terminals.Add(sym); break;
				case NodeType.Pragma: pragmas.Add(sym); break;
				case NodeType.NonTerminal: sym.n = nonterminals.Count; nonterminals.Add(sym); break;
			}
			return sym;
		}

		public bool TryFindSymbol(string name, out Symbol sym)
		{
			sym  = terminals.Concat(nonterminals).FirstOrDefault(x => x.Name == name);
			return sym is { };
		}

		int Num(Node p)
		{
			return p is null ? 0 : p.N;
		}

		void PrintSym(Symbol sym)
		{
			trace.Write("{0,3} {1,-14} {2}", sym.n, Name(sym.Name), nTyp[(int)sym.Type]);
			if (sym.attrPos == null) trace.Write(" false "); else trace.Write(" true  ");
			if (sym.Type == NodeType.NonTerminal)
			{
				trace.Write("{0,5}", Num(sym.graph));
				if (sym.deletable) trace.Write(" true  "); else trace.Write(" false ");
			}
			else
				trace.Write("            ");
			trace.WriteLine("{0,5} {1}", sym.line, tKind[sym.tokenKind]);
		}

		public void PrintSymbolTable()
		{
			trace.WriteLine("Symbol Table:");
			trace.WriteLine("------------"); trace.WriteLine();
			trace.WriteLine(" nr name          typ  hasAt graph  del    line tokenKind");
			foreach (Symbol sym in terminals) PrintSym(sym);
			foreach (Symbol sym in pragmas) PrintSym(sym);
			foreach (Symbol sym in nonterminals) PrintSym(sym);
			trace.WriteLine();
			trace.WriteLine("Literal Tokens:");
			trace.WriteLine("--------------");
			foreach (var e in literals)
			{
				trace.WriteLine($"_{e.Value.Name} = {e.Key}.");
			}
			trace.WriteLine();
		}

		public void PrintSet(BitArray s, int indent)
		{
			int col, len;
			col = indent;
			foreach (Symbol sym in terminals)
			{
				if (s[sym.n])
				{
					len = sym.Name.Length;
					if (col + len >= 80)
					{
						trace.WriteLine();
						for (col = 1; col < indent; col++) trace.Write(" ");
					}
					trace.Write("{0} ", sym.Name);
					col += len + 1;
				}
			}
			if (col == indent) trace.Write("-- empty set --");
			trace.WriteLine();
		}

		//---------------------------------------------------------------------
		//  Syntax graph management
		//---------------------------------------------------------------------

		public List<Node> nodes = new();

		public string[] nTyp =
			{"    ", "t   ", "pr  ", "nt  ", "clas", "chr ", "wt  ", "any ", "eps ",
		 "sync", "sem ", "alt ", "iter", "opt ", "rslv"};
		Node dummyNode;

		public Node NewNode(NodeType typ, Symbol sym, int line)
		{
			var node = new Node(nodes.Count, typ, sym, line);
			nodes.Add(node);
			return node;
		}

		public Node NewNode(NodeType typ, Node sub)
		{
			Node node = NewNode(typ, null, 0);
			node.sub = sub;
			return node;
		}

		public Node NewNode(NodeType typ, int val, int line)
		{
			Node node = NewNode(typ, null, line);
			node.val = val;
			return node;
		}

		public void MakeFirstAlt(Graph g)
		{
			g.Left = NewNode(NodeType.Alternative, g.Left);
			g.Left.Line = g.Left.sub.Line;
			g.Right.up = true;
			g.Left.next = g.Right;
			g.Right = g.Left;
		}

		// The result will be in g1
		public void MakeAlternative(Graph g1, Graph g2)
		{
			g2.Left = NewNode(NodeType.Alternative, g2.Left); g2.Left.Line = g2.Left.sub.Line;
			g2.Left.up = true;
			g2.Right.up = true;
			Node p = g1.Left; while (p.down != null) p = p.down;
			p.down = g2.Left;
			p = g1.Right; while (p.next != null) p = p.next;
			// append alternative to g1 end list
			p.next = g2.Left;
			// append g2 end list to g1 end list
			g2.Left.next = g2.Right;
		}

		// The result will be in g1
		public void MakeSequence(Graph g1, Graph g2)
		{
			Node p = g1.Right.next;
			g1.Right.next = g2.Left; // link head node
			while (p != null)
			{  // link substructure
				var q = p.next;
				p.next = g2.Left;
				p = q;
			}
			g1.Right = g2.Right;
		}

		public void MakeIteration(Graph g)
		{
			g.Left = NewNode(NodeType.Iteration, g.Left);
			g.Right.up = true;
			Node p = g.Right;
			g.Right = g.Left;
			while (p != null)
			{
				Node q = p.next; p.next = g.Left;
				p = q;
			}
		}

		public void MakeOption(Graph g)
		{
			g.Left = NewNode(NodeType.Option, g.Left);
			g.Right.up = true;
			g.Left.next = g.Right;
			g.Right = g.Left;
		}

		public void Finish(Graph g)
		{
			Node p = g.Right;
			while (p != null)
			{
				Node q = p.next; p.next = null;
				p = q;
			}
		}

		public void DeleteNodes()
		{
			nodes.Clear();
			dummyNode = NewNode(NodeType.Empty, null, 0);
		}

		public Graph StrToGraph(string str)
		{
			string s = Unescape(str[1..^1]);
			if (s.Length == 0) parser.SemErr("empty token not allowed");
			var r = dummyNode;
			for (int i = 0; i < s.Length; i++)
			{
				Node p = NewNode(NodeType.Character, (int)s[i], 0);
				r.next = p;
				r = p;
			}
			var g = new Graph(dummyNode.next, r);
			dummyNode.next = null;
			return g;
		}

		public void SetContextTrans(Node p)
		{ // set transition code in the graph rooted at p
			while (p != null)
			{
				if (p.Type == NodeType.Character || p.Type == NodeType.Class)
				{
					p.code = Node.contextTrans;
				}
				else if (p.Type == NodeType.Option || p.Type == NodeType.Iteration)
				{
					SetContextTrans(p.sub);
				}
				else if (p.Type == NodeType.Alternative)
				{
					SetContextTrans(p.sub); SetContextTrans(p.down);
				}
				if (p.up) break;
				p = p.next;
			}
		}

		//------------ graph deletability check -----------------

		public static bool DelGraph(Node p)
		{
			return p == null || DelNode(p) && DelGraph(p.next);
		}

		public static bool DelSubGraph(Node p)
		{
			return p == null || DelNode(p) && (p.up || DelSubGraph(p.next));
		}

		public static bool DelNode(Node p)
		{
			if (p.Type == NodeType.NonTerminal) return p.Symbol.deletable;
			else if (p.Type == NodeType.Alternative) return DelSubGraph(p.sub) || p.down != null && DelSubGraph(p.down);
			else return p.Type == NodeType.Iteration || p.Type == NodeType.Option || p.Type == NodeType.SemanticAction
				|| p.Type == NodeType.Empty || p.Type == NodeType.ResolverExpr || p.Type == NodeType.Synchronization;
		}

		//----------------- graph printing ----------------------

		string Ptr(Node p, bool up)
		{
			string ptr = (p == null) ? "0" : p.N.ToString();
			return (up) ? ("-" + ptr) : ptr;
		}

		string Pos(Position pos)
		{
			if (pos == null) return "     "; else return String.Format("{0,5}", pos.Begin);
		}

		public string Name(string name)
		{
			return (name + "           ").Substring(0, 12);
			// found no simpler way to get the first 12 characters of the name
			// padded with blanks on the right
		}

		public void PrintNodes()
		{
			trace.WriteLine("Graph nodes:");
			trace.WriteLine("----------------------------------------------------");
			trace.WriteLine("   n type name          next  down   sub   pos  line");
			trace.WriteLine("                               val  code");
			trace.WriteLine("----------------------------------------------------");
			foreach (Node p in nodes)
			{
				trace.Write("{0,4} {1} ", p.N, nTyp[(int)p.Type]);
				if (p.Symbol != null)
					trace.Write("{0,12} ", Name(p.Symbol.Name));
				else if (p.Type == NodeType.Class)
				{
					var c = classes[p.val];
					trace.Write("{0,12} ", Name(c.Name));
				}
				else trace.Write("             ");
				trace.Write("{0,5} ", Ptr(p.next, p.up));
				switch (p.Type)
				{
					case NodeType.Terminal:
					case NodeType.NonTerminal:
					case NodeType.WeakTerminal:
						trace.Write("             {0,5}", Pos(p.pos)); break;
					case NodeType.Character:
						trace.Write("{0,5} {1,5}       ", p.val, p.code); break;
					case NodeType.Class:
						trace.Write("      {0,5}       ", p.code); break;
					case NodeType.Alternative:
					case NodeType.Iteration:
					case NodeType.Option:
						trace.Write("{0,5} {1,5}       ", Ptr(p.down, false), Ptr(p.sub, false)); break;
					case NodeType.SemanticAction:
						trace.Write("             {0,5}", Pos(p.pos)); break;
					case NodeType.Empty:
					case NodeType.Any:
					case NodeType.Synchronization:
						trace.Write("                  "); break;
				}
				trace.WriteLine("{0,5}", p.Line);
			}
			trace.WriteLine();
		}


		//---------------------------------------------------------------------
		//  Character class management
		//---------------------------------------------------------------------

		public List<CharClass> classes = new();
		public int dummyName = 'A';

		public CharClass NewCharClass(string name, CharSet s)
		{
			if (name == "#") name = "#" + (char)dummyName++;
			CharClass c = new CharClass(classes.Count, name, s);
			classes.Add(c);
			return c;
		}

		public CharClass FindCharClass(string name)
		{
			foreach (CharClass c in classes)
				if (c.Name == name) return c;
			return null;
		}

		public CharClass FindCharClass(CharSet s)
		{
			foreach (CharClass c in classes)
				if (s.Equals(c.Set)) return c;
			return null;
		}

		public CharSet CharClassSet(int i)
		{
			return classes[i].Set;
		}

		//----------- character class printing

		string Ch(int ch)
		{
			if (ch < ' ' || ch >= 127 || ch == '\'' || ch == '\\') return ch.ToString();
			else return String.Format("'{0}'", (char)ch);
		}

		void WriteCharSet(CharSet s)
		{
			for (CharSet.Range r = s.head; r != null; r = r.next)
				if (r.from < r.to) { trace.Write(Ch(r.from) + ".." + Ch(r.to) + " "); }
				else { trace.Write(Ch(r.from) + " "); }
		}

		public void WriteCharClasses()
		{
			foreach (CharClass c in classes)
			{
				trace.Write("{0,-10}: ", c.Name);
				WriteCharSet(c.Set);
				trace.WriteLine();
			}
			trace.WriteLine();
		}


		//---------------------------------------------------------------------
		//  Symbol set computations
		//---------------------------------------------------------------------

		/* Computes the first set for the graph rooted at p */
		BitArray First0(Node p, BitArray mark)
		{
			BitArray fs = new BitArray(terminals.Count);
			while (p != null && !mark[p.N])
			{
				mark[p.N] = true;
				switch (p.Type)
				{
					case NodeType.NonTerminal:
						{
							if (p.Symbol.firstReady) fs.Or(p.Symbol.first);
							else fs.Or(First0(p.Symbol.graph, mark));
							break;
						}
					case NodeType.Terminal:
					case NodeType.WeakTerminal:
						{
							fs[p.Symbol.n] = true; break;
						}
					case NodeType.Any:
						{
							fs.Or(p.set); break;
						}
					case NodeType.Alternative:
						{
							fs.Or(First0(p.sub, mark));
							fs.Or(First0(p.down, mark));
							break;
						}
					case NodeType.Iteration:
					case NodeType.Option:
						{
							fs.Or(First0(p.sub, mark));
							break;
						}
				}
				if (!DelNode(p)) break;
				p = p.next;
			}
			return fs;
		}

		public BitArray First(Node p)
		{
			BitArray fs = First0(p, new BitArray(nodes.Count));
			if (ddt[3])
			{
				trace.WriteLine();
				if (p != null) trace.WriteLine("First: node = {0}", p.N);
				else trace.WriteLine("First: node = null");
				PrintSet(fs, 0);
			}
			return fs;
		}

		void CompFirstSets()
		{
			foreach (Symbol sym in nonterminals)
			{
				sym.first = new BitArray(terminals.Count);
				sym.firstReady = false;
			}
			foreach (Symbol sym in nonterminals)
			{
				sym.first = First(sym.graph);
				sym.firstReady = true;
			}
		}

		void CompFollow(Node p)
		{
			while (p != null && !visited[p.N])
			{
				visited[p.N] = true;
				if (p.Type == NodeType.NonTerminal)
				{
					BitArray s = First(p.next);
					p.Symbol.follow.Or(s);
					if (DelGraph(p.next))
						p.Symbol.nts[curSy.n] = true;
				}
				else if (p.Type == NodeType.Option || p.Type == NodeType.Iteration)
				{
					CompFollow(p.sub);
				}
				else if (p.Type == NodeType.Alternative)
				{
					CompFollow(p.sub); CompFollow(p.down);
				}
				p = p.next;
			}
		}

		void Complete(Symbol sym)
		{
			if (!visited[sym.n])
			{
				visited[sym.n] = true;
				foreach (Symbol s in nonterminals)
				{
					if (sym.nts[s.n])
					{
						Complete(s);
						sym.follow.Or(s.follow);
						if (sym == curSy) sym.nts[s.n] = false;
					}
				}
			}
		}

		void CompFollowSets()
		{
			foreach (Symbol sym in nonterminals)
			{
				sym.follow = new BitArray(terminals.Count);
				sym.nts = new BitArray(nonterminals.Count);
			}
			gramSy.follow[eofSy.n] = true;
			visited = new BitArray(nodes.Count);
			foreach (Symbol sym in nonterminals)
			{ // get direct successors of nonterminals
				curSy = sym;
				CompFollow(sym.graph);
			}
			foreach (Symbol sym in nonterminals)
			{ // add indirect successors to followers
				visited = new BitArray(nonterminals.Count);
				curSy = sym;
				Complete(sym);
			}
		}

		Node LeadingAny(Node p)
		{
			if (p == null) return null;
			Node a = null;
			if (p.Type == NodeType.Any) a = p;
			else if (p.Type == NodeType.Alternative)
			{
				a = LeadingAny(p.sub);
				if (a == null) a = LeadingAny(p.down);
			}
			else if (p.Type == NodeType.Option || p.Type == NodeType.Iteration) a = LeadingAny(p.sub);
			if (a == null && DelNode(p) && !p.up) a = LeadingAny(p.next);
			return a;
		}

		void FindAS(Node p)
		{ // find ANY sets
			Node a;
			while (p != null)
			{
				if (p.Type == NodeType.Option || p.Type == NodeType.Iteration)
				{
					FindAS(p.sub);
					a = LeadingAny(p.sub);
					if (a != null) a.set.Subtract(First(p.next));
				}
				else if (p.Type == NodeType.Alternative)
				{
					BitArray s1 = new BitArray(terminals.Count);
					Node q = p;
					while (q != null)
					{
						FindAS(q.sub);
						a = LeadingAny(q.sub);
						if (a != null)
							a.set.Subtract(First(q.down).Or(s1));
						else
							s1.Or(First(q.sub));
						q = q.down;
					}
				}

				// Remove alternative terminals before ANY, in the following
				// examples a and b must be removed from the ANY set:
				// [a] ANY, or {a|b} ANY, or [a][b] ANY, or (a|) ANY, or
				// A = [a]. A ANY
				if (DelNode(p))
				{
					a = LeadingAny(p.next);
					if (a != null)
					{
						Node q = (p.Type == NodeType.NonTerminal) ? p.Symbol.graph : p.sub;
						a.set.Subtract(First(q));
					}
				}

				if (p.up) break;
				p = p.next;
			}
		}

		void CompAnySets()
		{
			foreach (Symbol sym in nonterminals) FindAS(sym.graph);
		}

		public BitArray Expected(Node p, Symbol curSy)
		{
			BitArray s = First(p);
			if (DelGraph(p)) s.Or(curSy.follow);
			return s;
		}

		// does not look behind resolvers; only called during LL(1) test and in CheckRes
		public BitArray Expected0(Node p, Symbol curSy)
		{
			if (p.Type == NodeType.ResolverExpr) return new BitArray(terminals.Count);
			else return Expected(p, curSy);
		}

		void CompSync(Node p)
		{
			while (p != null && !visited[p.N])
			{
				visited[p.N] = true;
				if (p.Type == NodeType.Synchronization)
				{
					BitArray s = Expected(p.next, curSy);
					s[eofSy.n] = true;
					allSyncSets.Or(s);
					p.set = s;
				}
				else if (p.Type == NodeType.Alternative)
				{
					CompSync(p.sub); CompSync(p.down);
				}
				else if (p.Type == NodeType.Option || p.Type == NodeType.Iteration)
					CompSync(p.sub);
				p = p.next;
			}
		}

		void CompSyncSets()
		{
			allSyncSets = new BitArray(terminals.Count);
			allSyncSets[eofSy.n] = true;
			visited = new BitArray(nodes.Count);
			foreach (Symbol sym in nonterminals)
			{
				curSy = sym;
				CompSync(curSy.graph);
			}
		}

		public void SetupAnys()
		{
			foreach (Node p in nodes)
				if (p.Type == NodeType.Any)
				{
					p.set = new BitArray(terminals.Count, true);
					p.set[eofSy.n] = false;
				}
		}

		public void CompDeletableSymbols()
		{
			bool changed;
			do
			{
				changed = false;
				foreach (Symbol sym in nonterminals)
					if (!sym.deletable && sym.graph != null && DelGraph(sym.graph))
					{
						sym.deletable = true; changed = true;
					}
			} while (changed);
			foreach (Symbol sym in nonterminals)
				if (sym.deletable) errors.Warning("  " + sym.Name + " deletable");
		}

		public void RenumberPragmas()
		{
			int n = terminals.Count;
			foreach (Symbol sym in pragmas) sym.n = n++;
		}

		public void CompSymbolSets()
		{
			CompDeletableSymbols();
			CompFirstSets();
			CompAnySets();
			CompFollowSets();
			CompSyncSets();
			if (ddt[1])
			{
				trace.WriteLine();
				trace.WriteLine("First & follow symbols:");
				trace.WriteLine("----------------------"); trace.WriteLine();
				foreach (Symbol sym in nonterminals)
				{
					trace.WriteLine(sym.Name);
					trace.Write("first:   "); PrintSet(sym.first, 10);
					trace.Write("follow:  "); PrintSet(sym.follow, 10);
					trace.WriteLine();
				}
			}
			if (ddt[4])
			{
				trace.WriteLine();
				trace.WriteLine("ANY and SYNC sets:");
				trace.WriteLine("-----------------");
				foreach (Node p in nodes)
					if (p.Type == NodeType.Any || p.Type == NodeType.Synchronization)
					{
						trace.Write("{0,4} {1,4}: ", p.N, nTyp[(int)p.Type]);
						PrintSet(p.set, 11);
					}
			}
		}

		//---------------------------------------------------------------------
		//  String handling
		//---------------------------------------------------------------------

		char Hex2Char(string s)
		{
			int val = 0;
			for (int i = 0; i < s.Length; i++)
			{
				char ch = s[i];
				if ('0' <= ch && ch <= '9') val = 16 * val + (ch - '0');
				else if ('a' <= ch && ch <= 'f') val = 16 * val + (10 + ch - 'a');
				else if ('A' <= ch && ch <= 'F') val = 16 * val + (10 + ch - 'A');
				else parser.SemErr("bad escape sequence in string or character");
			}
			if (val > char.MaxValue) /* pdt */
				parser.SemErr("bad escape sequence in string or character");
			return (char)val;
		}

		string Char2Hex(char ch)
		{
			StringWriter w = new StringWriter();
			w.Write("\\u{0:x4}", (int)ch);
			return w.ToString();
		}

		public string Unescape(string s)
		{
			/* replaces escape sequences in s by their Unicode values. */
			StringBuilder buf = new StringBuilder();
			int i = 0;
			while (i < s.Length)
			{
				if (s[i] == '\\')
				{
					switch (s[i + 1])
					{
						case '\\': buf.Append('\\'); i += 2; break;
						case '\'': buf.Append('\''); i += 2; break;
						case '\"': buf.Append('\"'); i += 2; break;
						case 'r': buf.Append('\r'); i += 2; break;
						case 'n': buf.Append('\n'); i += 2; break;
						case 't': buf.Append('\t'); i += 2; break;
						case '0': buf.Append('\0'); i += 2; break;
						case 'a': buf.Append('\a'); i += 2; break;
						case 'b': buf.Append('\b'); i += 2; break;
						case 'f': buf.Append('\f'); i += 2; break;
						case 'v': buf.Append('\v'); i += 2; break;
						case 'u':
						case 'x':
							if (i + 6 <= s.Length)
							{
								buf.Append(Hex2Char(s.Substring(i + 2, 4))); i += 6; break;
							}
							else
							{
								parser.SemErr("bad escape sequence in string or character"); i = s.Length; break;
							}
						default: parser.SemErr("bad escape sequence in string or character"); i += 2; break;
					}
				}
				else
				{
					buf.Append(s[i]);
					i++;
				}
			}
			return buf.ToString();
		}

		public string Escape(string s)
		{
			StringBuilder buf = new StringBuilder();
			foreach (char ch in s)
			{
				switch (ch)
				{
					case '\\': buf.Append("\\\\"); break;
					case '\'': buf.Append("\\'"); break;
					case '\"': buf.Append("\\\""); break;
					case '\t': buf.Append("\\t"); break;
					case '\r': buf.Append("\\r"); break;
					case '\n': buf.Append("\\n"); break;
					default:
						if (ch < ' ' || ch > '\u007f') buf.Append(Char2Hex(ch));
						else buf.Append(ch);
						break;
				}
			}
			return buf.ToString();
		}

		//---------------------------------------------------------------------
		//  Grammar checks
		//---------------------------------------------------------------------

		public bool GrammarOk()
		{
			bool ok = NtsComplete()
				&& AllNtReached()
				&& NoCircularProductions()
				&& AllNtToTerm();
			if (ok) { CheckResolvers(); CheckLL1(); }
			return ok;
		}

		//--------------- check for circular productions ----------------------

		class CNode
		{   // node of list for finding circular productions
			public Symbol left, right;

			public CNode(Symbol l, Symbol r)
			{
				left = l; right = r;
			}
		}

		void GetSingles(Node p, List<Symbol> singles)
		{
			if (p == null) return;  // end of graph
			if (p.Type == NodeType.NonTerminal)
			{
				if (p.up || DelGraph(p.next)) singles.Add(p.Symbol);
			}
			else if (p.Type == NodeType.Alternative || p.Type == NodeType.Iteration || p.Type == NodeType.Option)
			{
				if (p.up || DelGraph(p.next))
				{
					GetSingles(p.sub, singles);
					if (p.Type == NodeType.Alternative) GetSingles(p.down, singles);
				}
			}
			if (!p.up && DelNode(p)) GetSingles(p.next, singles);
		}

		public bool NoCircularProductions()
		{
			bool ok, changed, onLeftSide, onRightSide;
			var list = new List<CNode>();
			foreach (Symbol sym in nonterminals)
			{
				var singles = new List<Symbol>();
				GetSingles(sym.graph, singles); // get nonterminals s such that sym-->s
				foreach (Symbol s in singles) list.Add(new CNode(sym, s));
			}
			do
			{
				changed = false;
				for (int i = 0; i < list.Count; i++)
				{
					CNode n = list[i];
					onLeftSide = false; onRightSide = false;
					foreach (CNode m in list)
					{
						if (n.left == m.right) onRightSide = true;
						if (n.right == m.left) onLeftSide = true;
					}
					if (!onLeftSide || !onRightSide)
					{
						list.Remove(n); i--; changed = true;
					}
				}
			} while (changed);
			ok = true;
			foreach (CNode n in list)
			{
				ok = false;
				errors.SemErr($"  {n.left.Name} --> {n.right.Name}");
			}
			return ok;
		}

		//--------------- check for LL(1) errors ----------------------

		void LL1Error(int cond, Symbol sym)
		{
			string s = "  LL1 warning in " + curSy.Name + ": ";
			if (sym != null) s += sym.Name + " is ";
			switch (cond)
			{
				case 1: s += "start of several alternatives"; break;
				case 2: s += "start & successor of deletable structure"; break;
				case 3: s += "an ANY node that matches no symbol"; break;
				case 4: s += "contents of [...] or {...} must not be deletable"; break;
			}
			errors.Warning(s);
		}

		void CheckOverlap(BitArray s1, BitArray s2, int cond)
		{
			foreach (Symbol sym in terminals)
			{
				if (s1[sym.n] && s2[sym.n]) LL1Error(cond, sym);
			}
		}

		void CheckAlts(Node p)
		{
			BitArray s1, s2;
			while (p != null)
			{
				if (p.Type == NodeType.Alternative)
				{
					Node q = p;
					s1 = new BitArray(terminals.Count);
					while (q != null)
					{ // for all alternatives
						s2 = Expected0(q.sub, curSy);
						CheckOverlap(s1, s2, 1);
						s1.Or(s2);
						CheckAlts(q.sub);
						q = q.down;
					}
				}
				else if (p.Type == NodeType.Option || p.Type == NodeType.Iteration)
				{
					if (DelSubGraph(p.sub)) LL1Error(4, null); // e.g. [[...]]
					else
					{
						s1 = Expected0(p.sub, curSy);
						s2 = Expected(p.next, curSy);
						CheckOverlap(s1, s2, 2);
					}
					CheckAlts(p.sub);
				}
				else if (p.Type == NodeType.Any)
				{
					if (p.set.Elements() == 0) LL1Error(3, null);
					// e.g. {ANY} ANY or [ANY] ANY or ( ANY | ANY )
				}
				if (p.up) break;
				p = p.next;
			}
		}

		public void CheckLL1()
		{
			foreach (Symbol sym in nonterminals)
			{
				curSy = sym;
				CheckAlts(curSy.graph);
			}
		}

		//------------- check if resolvers are legal  --------------------

		void ResErr(Node p, string msg)
		{
			errors.Warning(p.Line, p.pos.Column, msg);
		}

		void CheckRes(Node p, bool rslvAllowed)
		{
			while (p != null)
			{
				switch (p.Type)
				{
					case NodeType.Alternative:
						BitArray expected = new BitArray(terminals.Count);
						for (Node q = p; q != null; q = q.down)
							expected.Or(Expected0(q.sub, curSy));
						BitArray soFar = new BitArray(terminals.Count);
						for (Node q = p; q != null; q = q.down)
						{
							if (q.sub.Type == NodeType.ResolverExpr)
							{
								BitArray fs = Expected(q.sub.next, curSy);
								if (fs.Intersect(soFar))
									ResErr(q.sub, "Warning: Resolver will never be evaluated. " +
									"Place it at previous conflicting alternative.");
								if (!fs.Intersect(expected))
									ResErr(q.sub, "Warning: Misplaced resolver: no LL(1) conflict.");
							}
							else soFar.Or(Expected(q.sub, curSy));
							CheckRes(q.sub, true);
						}
						break;
					case NodeType.Iteration:
					case NodeType.Option:
						if (p.sub.Type == NodeType.ResolverExpr)
						{
							BitArray fs = First(p.sub.next);
							BitArray fsNext = Expected(p.next, curSy);
							if (!fs.Intersect(fsNext))
								ResErr(p.sub, "Warning: Misplaced resolver: no LL(1) conflict.");
						}
						CheckRes(p.sub, true);
						break;
					case NodeType.ResolverExpr:
						if (!rslvAllowed)
							ResErr(p, "Warning: Misplaced resolver: no alternative.");
						break;
				}
				if (p.up) break;
				p = p.next;
				rslvAllowed = false;
			}
		}

		public void CheckResolvers()
		{
			foreach (Symbol sym in nonterminals)
			{
				curSy = sym;
				CheckRes(curSy.graph, false);
			}
		}

		//------------- check if every nts has a production --------------------

		public bool NtsComplete()
		{
			bool complete = true;
			foreach (Symbol sym in nonterminals)
			{
				if (sym.graph == null)
				{
					complete = false;
					errors.SemErr("  No production for " + sym.Name);
				}
			}
			return complete;
		}

		//-------------- check if every nts can be reached  -----------------

		void MarkReachedNts(Node p)
		{
			while (p != null)
			{
				if (p.Type == NodeType.NonTerminal && !visited[p.Symbol.n])
				{ // new nt reached
					visited[p.Symbol.n] = true;
					MarkReachedNts(p.Symbol.graph);
				}
				else if (p.Type == NodeType.Alternative || p.Type == NodeType.Iteration || p.Type == NodeType.Option)
				{
					MarkReachedNts(p.sub);
					if (p.Type == NodeType.Alternative) MarkReachedNts(p.down);
				}
				if (p.up) break;
				p = p.next;
			}
		}

		public bool AllNtReached()
		{
			bool ok = true;
			visited = new BitArray(nonterminals.Count);
			visited[gramSy.n] = true;
			MarkReachedNts(gramSy.graph);
			foreach (Symbol sym in nonterminals)
			{
				if (!visited[sym.n])
				{
					ok = false;
					errors.Warning("  " + sym.Name + " cannot be reached");
				}
			}
			return ok;
		}

		//--------- check if every nts can be derived to terminals  ------------

		bool IsTerm(Node p, BitArray mark)
		{ // true if graph can be derived to terminals
			while (p != null)
			{
				if (p.Type == NodeType.NonTerminal && !mark[p.Symbol.n]) return false;
				if (p.Type == NodeType.Alternative && !IsTerm(p.sub, mark)
				&& (p.down == null || !IsTerm(p.down, mark))) return false;
				if (p.up) break;
				p = p.next;
			}
			return true;
		}

		public bool AllNtToTerm()
		{
			bool changed, ok = true;
			BitArray mark = new BitArray(nonterminals.Count);
			// a nonterminal is marked if it can be derived to terminal symbols
			do
			{
				changed = false;
				foreach (Symbol sym in nonterminals)
					if (!mark[sym.n] && IsTerm(sym.graph, mark))
					{
						mark[sym.n] = true; changed = true;
					}
			} while (changed);
			foreach (Symbol sym in nonterminals)
				if (!mark[sym.n])
				{
					ok = false;
					errors.SemErr("  " + sym.Name + " cannot be derived to terminals");
				}
			return ok;
		}

		//---------------------------------------------------------------------
		//  Cross reference list
		//---------------------------------------------------------------------

		public void XRef()
		{
			var xref = new Dictionary<Symbol, List<int>>();
			// collect lines where symbols have been defined
			foreach (Symbol sym in nonterminals)
			{
				var list = xref[sym];
				if (list == null)
				{
					list = new List<int>();
					xref[sym] = list;
				}
				list.Add(-sym.line);
			}

			// collect lines where symbols have been referenced
			foreach (Node n in nodes)
			{
				if (n.Type == NodeType.Terminal || n.Type == NodeType.WeakTerminal || n.Type == NodeType.NonTerminal)
				{
					var list = xref[n.Symbol];
					if (list == null)
					{
						list = new List<int>();
						xref[n.Symbol] = list;
					}
					list.Add(n.Line);
				}
			}
			// print cross reference list
			trace.WriteLine();
			trace.WriteLine("Cross reference list:");
			trace.WriteLine("--------------------"); trace.WriteLine();
			foreach (Symbol sym in xref.Keys)
			{
				trace.Write("  {0,-12}", Name(sym.Name));
				var list = xref[sym];
				int col = 14;
				foreach (int line in list)
				{
					if (col + 5 > 80)
					{
						trace.WriteLine();
						for (col = 1; col <= 14; col++) trace.Write(" ");
					}
					trace.Write("{0,5}", line); col += 5;
				}
				trace.WriteLine();
			}
			trace.WriteLine(); trace.WriteLine();
		}

		public void SetDDT(string s)
		{
			s = s.ToUpper();
			foreach (char ch in s)
			{
				if ('0' <= ch && ch <= '9') ddt[ch - '0'] = true;
				else switch (ch)
					{
						case 'A': ddt[0] = true; break; // trace automaton
						case 'F': ddt[1] = true; break; // list first/follow sets
						case 'G': ddt[2] = true; break; // print syntax graph
						case 'I': ddt[3] = true; break; // trace computation of first sets
						case 'J': ddt[4] = true; break; // print ANY and SYNC sets
						case 'P': ddt[8] = true; break; // print statistics
						case 'S': ddt[6] = true; break; // list symbol table
						case 'X': ddt[7] = true; break; // list cross reference table
						default: break;
					}
			}
		}

		public void SetOption(string s)
		{
			string[] option = s.Split(new char[] { '=' }, 2);
			string name = option[0], value = option[1];
			if ("$namespace".Equals(name))
			{
				if (nsName == null) nsName = value;
			}
			else if ("$checkEOF".Equals(name))
			{
				checkEOF = "true".Equals(value);
			}
		}
	}
}
